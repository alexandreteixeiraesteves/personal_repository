-- Code generated by the MiniLucid Compiler
open Complex
open Sndlib
open Myprog
const zero_f_256 = 0.000000^256
machine float_to_complex =
  step(f: float) returns (c: Complex.complex) {
    c = {Complex.re = f;
         Complex.im = 0.000000}
  }

machine complex_to_float =
  step(c: Complex.complex) returns (f: float) {
    f = c.re
  }

machine main =
  var s1: float^256; s2: float^256; s3: float^256;
  obj n : Myprog.myread;n_4 : float_to_complex[1024];
      n_6 : complex_to_float[256];n_7 : Myprog.mywrite;
  
  step() returns () {
    var v_1: float^(256 + (256 + 256)); v: float^(256 + 256); s0: float^256;
        t: float^256; s: float^1024; c0: Complex.complex^1024;
        c3: Complex.complex^256;
    (s0) = n.step(256);
    for i_7: int = 0 to 256 {
       v[i_7] = mem(s1)[i_7] 
    };
    for i_8: int = 0 to 256 {
       v[((+) 256 i_8)] = s0[i_8] 
    };
    for i_5: int = 0 to 256 {
       v_1[i_5] = mem(s2)[i_5] 
    };
    for i_6: int = 0 to (256 + 256) {
       v_1[((+) 256 i_6)] = v[i_6] 
    };
    for i_3: int = 0 to 256 {
       s[i_3] = mem(s3)[i_3] 
    };
    for i_4: int = 0 to (256 + (256 + 256)) {
       s[((+) 256 i_4)] = v_1[i_4] 
    };
    for i_2: int = 0 to 1024 {
       (c0[i_2]) = n_4[i_2].step(s[i_2]) 
    };
    for i_1: int = 0 to (1 + (255 - 0)) {
       c3[i_1] = c0[((+) i_1 0)] 
    };
    for i: int = 0 to 256 {
       (t[i]) = n_6[i].step(c3[i]) 
    };
    n_7.step(256, t);
    mem(s3) = mem(s2);
    mem(s2) = mem(s1);
    mem(s1) = s0
  }

  reset() returns () {
    for i_2: int = 0 to 1024 {
        
    };
    for i: int = 0 to 256 {
        
    };
    mem(s3) = zero_f_256;
    mem(s2) = zero_f_256;
    mem(s1) = zero_f_256
  }


